/**
 * # Sanidate
 *
 * Validation-sanitizing functionality for web frameworks, browsers, and
 * you-name-it.
 *
 * @author Monwara LLC / Branko Vukelic <branko@brankovukeluc.com>
 * @version 0.0.3
 * @license MIT
 *//**
 * ## Overview
 *
 * Sanidate (SANItize + valiDATE) is a JavaScript library for validating and
 * sanitizing user-supplied data. It uses a developer-defined constraint schema
 * and converts input data into valid and properly formatted data. It can be
 * used both on server- and client-side, and provides middlewares for
 * [Express.js](http://expressjs.com/), and 
 * [FragRouter](https://github.com/foxbunny/FragRouter), as well as a jQuery
 * plugin.
 *
 * Sanidate grew out of author's frustration with existing validation
 * frameworks which tend to produce a lot of cruft, and/or create unreasonably
 * hard-to-read, verbose code. Data validation and sanitizing is a very common
 * task (virtually _all_ user input has to be validated and/or sanitized at
 * some point), repetitive, and outright boring. On top of it, it's not even
 * the _most important_ part of the business logic, but merely an overture.
 *
 * Sanidate tries to reduce validation and sanitizing to what it's supposed to
 * be, merely a checklist for what the data should look like before it can be
 * consumed by business logic code. It also tries to reduce validation and
 * sanitizing into a single pass (called 'sanidation'), so you don't have to do
 * two mentally very close tasks tasks in two separate passes. Finally, it
 * systematizes data into a convenient package, so you can access it with ease,
 * rather than hunt for it in multiple different places.
 *
 * The core of Sanidate is its constraints system. Each constraint is a
 * function which does two things:
 *
 *  + converts data into intended data _type_
 *  + checks the validity of the data
 *
 * These constraints are named, and a sanidation schema can be contructed using
 * the names, instead of references to functions. This makes for concise
 * representation of the sanidation schema (more on that in the following
 * section).
 *
 * Unlike some of the validation frameworks for JavaScript, Sanidate is fully
 * asynchronous, which means it supports asynchronous operations like database
 * lookups in its constraint functions. In fact, it ships with two
 * Mongoose-specific constraints all good to go.
 *
 * ## Sanidation schema
 *
 * Sanidation schema is an object that describes your desired output. Since
 * input is almost always string, Sanidate not only checks the validity of the
 * strings, but also converts them into desired type and/or format. The
 * conversion and validation for a single constraint are both controlled by a
 * single constraint function.
 *
 * Let's take a look at a simple sanidation schema and then discuss its
 * structure in more detail:
 *
 *     var schema = {
 *       name: 'required',
 *       email: 'email',
 *       age: 'integer',
 *       username: 'required',
 *       profilePicture: [
 *         ['custom', checkStorage]
 *       ]
 *     };
 *
 * You will first notice that, for most part, schema is simply a key-value
 * pair, where keys are parameter names, and values are strings or arrays. 
 *
 * Strings values are very simple: they are names of built-in constraints
 * (e.g., 'required', 'email', 'numeric'...). 
 *
 * For specifying multiple constraints, or specifying constraints with
 * parameters, arrays must be used. Each member of the constraint array is a
 * single constraint, and it can be either a string or an array. Strings are
 * the same as string values above: just names of built-in constraints.
 * Constraint represented by an array has the name of the built-in constraint
 * as it's first member, and other members are arguments passed to the
 * constraint function.
 *
 * In our example, `profilePicture` parameter has a single constraint called
 * 'custom', with a single argument, which is a reference to a function caleld
 * `checkStorage` (which, you can imagine, checks the hard drive for profile
 * image file and fails validation if one is not found).
 *
 * The built-in constraints, such as 'required' or 'email', are all stored in
 * `sanidate.funcs` object. They are looked up internally when validation takes
 * place, but are exposed for your convenience, if you ever need to customize
 * them, or add new constraints yourself.
 *
 * One thing to note about the constraints such as 'numeric' is that they will
 * actually convert the input data into an appropriate type (e.g., 'numeric'
 * converts to a float, 'integer' converts to an integer, and 'date' converts
 * to `Date` object).
 *
 * Another important note is that all constraints require a value to be
 * present. Currently, there is no support for optional constraints that are
 * applied only when data is present. If you wish to apply constraints only if
 * a value is present, use the 'optional' constraint as the first constraint,
 * followed by other constraints.
 *
 * ## Constraint chaining
 *
 * If you use more than one constraint on a parameter, you should keep in mind
 * that each constraint transforms data before passing to the next one. For
 * example, if you put a 'match' constraint _after_ the 'date' constraint, this
 * will yield unexpected results, because the value will have been transformed
 * into a `Date` object before reaching the 'match' constraint.
 *
 * Think of constraint arrays as layers of filters one on top of the other on
 * which you drip the data.
 *
 * The built-in constraints are constructed in such a way that you usually only
 * need one of them at a time, so chaining should generally not be required.
 * For example, 'max' constraint may also serve as either 'numeric' or 
 * 'integer' constraint becuase it will fail if value is not a valid number.
 *
 * ## Built-in constraints
 *
 * Sanidate ships with a handful of (arguably) very useful constraints. These
 * are (with arguments in square brackets):
 *
 *  + required: Simply fails if value is not supplied
 *  + optional: [def] If no value is supplied, return the default value
 *    (`def`), and interrupt execution of further constraints; must be the
 *    first constraint if used with other constraints
 *  + match: [pattern] Fails if value does not match the regexp `pattern`
 *  + numeric: Forces conversion to float, and fails when conversion fails
 *  + integer: Forces conversion to integer and fails when conversion fails
 *  + max: [x, integer] Forces conversion to float or integer (if `integer` 
 *    flag is set to `true`), and fails if greater than `x`
 *  + min: [x, integer] Same as `max`, but fails if less than `x`
 *  + date: Forces conversion to Date, and fails if conversion fails (does not
 *    work with any particular date format, so if date formatting is required, 
 *    insert the `match` constraint before date constraint)
 *  + email: Fails if value is not an email
 *  + zip: Fails if value is not a 5-digit number (such as US zip code)
 *  + phone: [digitsOnly] Fails if value does not _contain_ 10 digits 
 *    (disregaring any other non-numeric characters), and returns either only
 *    the digits (if `digitsOnly` flag is set to `true`), or formatted phone
 *    number (currently only supports US phone format)
 *  + isTrue: Returns `true` if value is 'true', 'yes', 'on', or '1', otherwise
 *    returns `false`, and never fails
 *  + isNotTrue: Returns `false` if value is 'false', 'no', 'off', or '0',
 *    otherwise returns `true`, and never fails
 *  + isDocument: [Model, key] Looks up Mongoose model using either supplied
 *    optional `key`, or parameter name as key name, and fails if no documents
 *    are found; value is converted to returned document
 *  + isNotDocument: [Model, key] Same as 'isDocument', but fails if document
 *    _is_ found, and returns original value on success.
 *  + custom: [func] Uses the `func` function as constraint
 *  + derive: [paramName, func] Uses parameter `paramName` from original
 *    user-supplied data, and applies `func` validation function to its value
 *
 * Note that you _can_ use multiple 'custom' constraints for any user-supplied
 * data.
 *
 * ## Generic JavaScript example
 *
 *     var data = {
 *       email: 'test@example.com',
 *       number: '11'
 *     };
 *
 *     var schema = {
 *       name: 'required',
 *       email: 'email',
 *       number: 'integer'
 *     };
 *
 *     sanidate.check(data, schema, function(err, data) {
 *       console.log(err.count); // logs 1
 *       console.log(err.errors.name); logs 'required'
 *       // data is:
 *       //   {email: 'test@example.com', number: 11}
 *     });
 *
 * ## Express.js example
 *
 *     var schema = {
 *       name: 'required',
 *       email: 'email',
 *       number: 'integer'
 *     };
 *
 *     // Set up middleware using `sanidate.express()` call
 *     app.post('/user', sanidate.express(schema), function(req, res) {
 *       if (req.dataError) { return req.send('Error', 400); }
 *
 *       // Sanidated data is now available as req.data
 *
 *       req.send('Success!', 200);
 *     });
 *
 * ## FragRouter example
 *
 *     frag.addMiddleware(sanidate.frag);
 *
 *     function myHandler() {
 *       var schema = {
 *         name: 'required',
 *         email: 'email',
 *         number: 'integer'
 *       };
 *
 *       // get `data` from somewhere
 *
 *       this.sanidate(data, schema)
 *     }
 *
 * ## jQuery example
 *
 * Although Sanidate _is_ an AMD module, it doesn't list jQuery as its
 * dependency, since it doesn't actually _need_ it. 
 *
 * If you want to use Sanidate's jQuery plugin, you need to make sure Sanidate
 * is loaded _after_ jQuery, or configure your AMD loader to load jQuery as
 * Sanidate's dependency.
 *
 * Alternatively, you can run this line after jQuery has been loaded:
 *
 *     sanidate.jQuery($);
 *
 * After you've successfully activated the plugin, you can use it like this:
 *
 *     var schema = {
 *       name: 'required',
 *       email: 'email',
 *       number: 'integer'
 *     };
 *
 *     $('#myForm').sanidate(schema, function(err, data) {
 *       // `err` and `data` are the usual objects
 *     });
 *
 */(function(e,t){typeof define=="function"&&define.amd?define([],t):typeof module=="object"&&module.exports?module.exports=t():e.sanidate=t()})(this,function(){function r(e){var t=/\d+/g,n="";while(match=t.exec(e))n+=match[0];return n}function i(e){return e=r(e),"("+e.slice(0,3)+") "+e.slice(3,6)+"-"+e.slice(6)}var e={},t=/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,n=/^\(?\d{3}\)? ?\d{3}-?\d{4}$/;return e.funcs={required:function(){return function(e,t){t(null,e?e:null,"required")}},match:function(e){return function(t,n){n(null,e.exec(t)?t:null,"match")}},numeric:function(){return function(e,t){var n=parseFloat(e);t(null,isNaN(n)?null:n,"numeric")}},integer:function(){return function(e,t){var n=parseInt(e,10);t(null,isNaN(n)?null:n,"integer")}},min:function(e,t){return function(n,r){var i=t?parseInt(n,10):parseFloat(n);r(null,!isNaN(i)&&i>e?i:null,"min")}},max:function(e,t){return function(n,r){var i=t?parseInt(n,10):parseFloat(n);r(null,!isNaN(i)&&i<=e?i:null,"min")}},date:function(){return function(e,t){var n=new Date(e);t(null,n.toString()!=="Invalid Date"?n:null,"date")}},email:function(){return function(e,n){n(null,t.exec(e)?e:null,"email")}},zip:function(){return function(e,t){t(null,/^\d{5}$/.exec(e)?e:null,"zip")}},isTrue:function(){return function(e,t){t(null,"true yes 1 on".split(" ").indexOf(e)>-1,"isTrue")}},isNotFalse:function(){return function(e,t){t(null,"false no 0 off".split(" ").indexOf(e)<0,"isFalse")}},phone:function(e){return function(t,s){s(null,n.exec(t)?e?r(t):i(t):null,"phone")}},isDocument:function(e,t){return t=t||this.name,function(n,r){var i={};i[t]=n,e.findOne(i,function(e,t){e&&r(e,null,"isDocument"),r(null,t||null,"isDocument")})}},isNotDocument:function(e,t){return t=t||this.name,function(n,r){var i={};i[t]=n,e.findOne(i,function(e,t){e&&r(e,null,"isNotDocument"),r(null,t?null:n,"isNotDocument")})}},custom:function(e){return e},optional:function(e){var t=this.originalValue||e;return function(e,n){n(null,e?e:t,e?"optional":null)}},derive:function(e,t){var n=this.originalData[e];return function(e,r){t.call(n,e,r)}}},e.checkParam=function(t,n,r,i,s){function u(e,t,n){if(!e.length)return n(null,t);e[0](t,function(t,r,i,s){if(t)return n(t,null,i);if(r===null)return n(null,null,i);if(i===null)return n(null,r);u(e.slice(1),r,n)})}var o={name:t,originalValue:n,originalData:i};typeof r=="string"&&(r=[r]),r=r.map(function(t){var n,r;typeof t=="string"?(n=e.funcs[t],r=[]):(n=e.funcs[t[0]],r=t.slice(1));if(typeof n!="function")throw new Error("Constraint "+t+" is not a function "+"for param "+parameterName);return n.apply(o,r)}),u(r,n,s)},e.check=function(t,n,r,i){var s={},o={count:0,errors:{}},u=Object.keys(n).length;Object.keys(n).forEach(function(a){e.checkParam(a,t[a],n[a],t,function(e,t,n){if(e||t===null)o.count+=1,o.errors[a]=n;else if(!r||typeof t!="undefined"&&t!==null)s[a]=t;u--,u||i(o,s)})})},e.express=function(t,n){return function(r,i,s){r.sanidateFuncs=e.funcs,r.sanidate=e.check;if(t){var o={};Object.keys(t).forEach(function(e){o[e]=r.param(e)}),e.check(o,t,n,function(e,t){r.data=t,e.count&&(r.dataErrors=e),s()})}else s()}},e.frag=function(t){return function(t){this.sanidateFuncs=e.funcs,this.sanidate=e.check}},e.jQuery=function(t){t.fn.sanidate=function(n,r){var i=t(this),s={};Object.keys(n).forEach(function(e){s[e]=i.find(":input[name="+e+"]").val()}),e.check(s,n,r)}},jQuery&&typeof jQuery=="function"&&jQuery.fn&&e.jQuery(jQuery),e});